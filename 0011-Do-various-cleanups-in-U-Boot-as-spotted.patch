From 3cbca80008850d06bb7ac1e1dc7939eeafcf68f4 Mon Sep 17 00:00:00 2001
From: Dragan Simic <dragan.simic@gmail.com>
Date: Thu, 30 Dec 2021 00:10:36 +0100
Subject: [PATCH 2/2] Do various cleanups in U-Boot, as spotted

---
 common/spl/spl.c                 |  2 --
 drivers/core/device.c            | 22 ++++++++------------
 drivers/core/lists.c             | 32 +++++++++++------------------
 drivers/core/root.c              | 35 ++++++++++++--------------------
 drivers/core/uclass.c            |  8 ++++----
 drivers/i2c/i2c-uclass.c         | 28 ++++++++-----------------
 drivers/power/pmic/pmic-uclass.c | 11 ++++------
 drivers/power/pmic/rk8xx.c       | 22 +++++++++++---------
 8 files changed, 63 insertions(+), 97 deletions(-)

diff --git a/common/spl/spl.c b/common/spl/spl.c
index 63c48fbf..aa73350f 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -628,8 +628,6 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 		}
 	}
 	if (CONFIG_IS_ENABLED(HANDOFF)) {
-		int ret;
-
 		ret = setup_spl_handoff();
 		if (ret) {
 			puts(SPL_TPL_PROMPT "Cannot set up SPL handoff\n");
diff --git a/drivers/core/device.c b/drivers/core/device.c
index 4b3dcb3b..39dd8f16 100644
--- a/drivers/core/device.c
+++ b/drivers/core/device.c
@@ -86,11 +86,11 @@ static int device_bind_common(struct udevice *parent, const struct driver *drv,
 		    !CONFIG_IS_ENABLED(OF_PLATDATA)) {
 			if (uc->uc_drv->name && ofnode_valid(node))
 				dev_read_alias_seq(dev, &dev->req_seq);
-#if CONFIG_IS_ENABLED(OF_PRIOR_STAGE)
-			if (dev->req_seq == -1)
-				dev->req_seq =
-					uclass_find_next_free_req_seq(drv->id);
-#endif
+
+			if (CONFIG_IS_ENABLED(OF_PRIOR_STAGE)) {
+				if (dev->req_seq == -1)
+					dev->req_seq = uclass_find_next_free_req_seq(drv->id);
+			}
 		} else {
 			dev->req_seq = uclass_find_next_free_req_seq(drv->id);
 		}
@@ -102,22 +102,19 @@ static int device_bind_common(struct udevice *parent, const struct driver *drv,
 		if (CONFIG_IS_ENABLED(OF_PLATDATA)) {
 			if (of_platdata_size) {
 				dev->flags |= DM_FLAG_OF_PLATDATA;
-				if (of_platdata_size <
-						drv->platdata_auto_alloc_size)
+				if (of_platdata_size < drv->platdata_auto_alloc_size)
 					alloc = true;
 			}
 		}
 		if (alloc) {
 			dev->flags |= DM_FLAG_ALLOC_PDATA;
-			dev->platdata = calloc(1,
-					       drv->platdata_auto_alloc_size);
+			dev->platdata = calloc(1, drv->platdata_auto_alloc_size);
 			if (!dev->platdata) {
 				ret = -ENOMEM;
 				goto fail_alloc1;
 			}
 			if (CONFIG_IS_ENABLED(OF_PLATDATA) && platdata) {
-				memcpy(dev->platdata, platdata,
-				       of_platdata_size);
+				memcpy(dev->platdata, platdata, of_platdata_size);
 			}
 		}
 	}
@@ -135,8 +132,7 @@ static int device_bind_common(struct udevice *parent, const struct driver *drv,
 	if (parent) {
 		size = parent->driver->per_child_platdata_auto_alloc_size;
 		if (!size) {
-			size = parent->uclass->uc_drv->
-					per_child_platdata_auto_alloc_size;
+			size = parent->uclass->uc_drv->per_child_platdata_auto_alloc_size;
 		}
 		if (size) {
 			dev->flags |= DM_FLAG_ALLOC_PARENT_PDATA;
diff --git a/drivers/core/lists.c b/drivers/core/lists.c
index b23ee303..9c28060d 100644
--- a/drivers/core/lists.c
+++ b/drivers/core/lists.c
@@ -22,8 +22,7 @@
 
 struct driver *lists_driver_lookup_name(const char *name)
 {
-	struct driver *drv =
-		ll_entry_start(struct driver, driver);
+	struct driver *drv = ll_entry_start(struct driver, driver);
 	const int n_ents = ll_entry_count(struct driver, driver);
 	struct driver *entry;
 
@@ -38,8 +37,7 @@ struct driver *lists_driver_lookup_name(const char *name)
 
 struct uclass_driver *lists_uclass_lookup(enum uclass_id id)
 {
-	struct uclass_driver *uclass =
-		ll_entry_start(struct uclass_driver, uclass);
+	struct uclass_driver *uclass = ll_entry_start(struct uclass_driver, uclass);
 	const int n_ents = ll_entry_count(struct uclass_driver, uclass);
 	struct uclass_driver *entry;
 
@@ -53,8 +51,7 @@ struct uclass_driver *lists_uclass_lookup(enum uclass_id id)
 
 static int bind_drivers_pass(struct udevice *parent, bool pre_reloc_only)
 {
-	struct driver_info *info =
-		ll_entry_start(struct driver_info, driver_info);
+	struct driver_info *info = ll_entry_start(struct driver_info, driver_info);
 	const int n_ents = ll_entry_count(struct driver_info, driver_info);
 	bool missing_parent = false;
 	int result = 0;
@@ -192,7 +189,6 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 	bool found = false;
 	const char *name, *compat_list, *compat;
 	int compat_length, i;
-	int result = 0;
 	int ret = 0;
 
 	if (devp)
@@ -203,8 +199,7 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 	compat_list = ofnode_get_property(node, "compatible", &compat_length);
 	if (!compat_list) {
 		if (compat_length == -FDT_ERR_NOTFOUND) {
-			log_debug("Device '%s' has no compatible string\n",
-				  name);
+			log_debug("Device '%s' has no compatible string\n", name);
 			return 0;
 		}
 
@@ -219,12 +214,10 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 	 */
 	for (i = 0; i < compat_length; i += strlen(compat) + 1) {
 		compat = compat_list + i;
-		log_debug("   - attempt to match compatible string '%s'\n",
-			  compat);
+		log_debug("   - attempt to match compatible string '%s'\n", compat);
 
 		for (entry = driver; entry != driver + n_ents; entry++) {
-			ret = driver_check_compatible(entry->of_match, &id,
-						      compat);
+			ret = driver_check_compatible(entry->of_match, &id, compat);
 			if (!ret)
 				break;
 		}
@@ -240,8 +233,8 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 		}
 
 		log_debug("   - found match at '%s': '%s' matches '%s'\n",
-			  entry->name, entry->of_match->compatible,
-			  id->compatible);
+			  entry->name, entry->of_match->compatible, id->compatible);
+
 		ret = device_bind_with_driver_data(parent, entry, name,
 						   id->data, node, &dev);
 		if (ret == -ENODEV) {
@@ -249,8 +242,7 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 			continue;
 		}
 		if (ret) {
-			dm_warn("Error binding driver '%s': %d\n", entry->name,
-				ret);
+			dm_warn("Error binding driver '%s': %d\n", entry->name, ret);
 			return ret;
 		} else {
 			found = true;
@@ -260,9 +252,9 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 		break;
 	}
 
-	if (!found && !result && ret != -ENODEV)
+	if (!found && ret != -ENODEV)
 		log_debug("No match for node '%s'\n", name);
 
-	return result;
+	return 0;
 }
-#endif
+#endif /* OF_CONTROL && !OF_PLATDATA */
diff --git a/drivers/core/root.c b/drivers/core/root.c
index 5f10d7a3..e4e0c978 100644
--- a/drivers/core/root.c
+++ b/drivers/core/root.c
@@ -52,8 +52,7 @@ void dm_fixup_for_gd_move(struct global_data *new_gd)
 
 void fix_drivers(void)
 {
-	struct driver *drv =
-		ll_entry_start(struct driver, driver);
+	struct driver *drv = ll_entry_start(struct driver, driver);
 	const int n_ents = ll_entry_count(struct driver, driver);
 	struct driver *entry;
 
@@ -85,8 +84,7 @@ void fix_drivers(void)
 
 void fix_uclass(void)
 {
-	struct uclass_driver *uclass =
-		ll_entry_start(struct uclass_driver, uclass);
+	struct uclass_driver *uclass = ll_entry_start(struct uclass_driver, uclass);
 	const int n_ents = ll_entry_count(struct uclass_driver, uclass);
 	struct uclass_driver *entry;
 
@@ -117,8 +115,7 @@ void fix_uclass(void)
 
 void fix_devices(void)
 {
-	struct driver_info *dev =
-		ll_entry_start(struct driver_info, driver_info);
+	struct driver_info *dev = ll_entry_start(struct driver_info, driver_info);
 	const int n_ents = ll_entry_count(struct driver_info, driver_info);
 	struct driver_info *entry;
 
@@ -152,7 +149,7 @@ int dm_init(bool of_live)
 		DM_ROOT_NON_CONST->node = np_to_ofnode(gd_of_root());
 	else
 		DM_ROOT_NON_CONST->node = offset_to_ofnode(0);
-#endif
+#endif /* OF_CONTROL */
 	ret = device_probe(DM_ROOT_NON_CONST);
 	if (ret)
 		return ret;
@@ -176,7 +173,7 @@ int dm_remove_devices_flags(uint flags)
 
 	return 0;
 }
-#endif
+#endif /* DM_DEVICE_REMOVE */
 
 int dm_scan_platdata(bool pre_reloc_only)
 {
@@ -211,13 +208,11 @@ static int dm_scan_fdt_live(struct udevice *parent,
 	int ret = 0, err;
 
 	for (np = node_parent->child; np; np = np->sibling) {
-
 		if (!of_device_is_available(np)) {
 			pr_debug("   - ignoring disabled device\n");
 			continue;
 		}
-		err = lists_bind_fdt(parent, np_to_ofnode(np), NULL,
-				     pre_reloc_only);
+		err = lists_bind_fdt(parent, np_to_ofnode(np), NULL, pre_reloc_only);
 		if (err && !ret) {
 			ret = err;
 			debug("%s: ret=%d\n", np->name, ret);
@@ -254,11 +249,10 @@ static int dm_scan_fdt_node(struct udevice *parent, const void *blob,
 		const char *node_name = fdt_get_name(blob, offset, NULL);
 
 		if (!fdtdec_get_is_enabled(blob, offset)) {
-			pr_debug("   - ignoring disabled device\n");
+			debug("   - ignoring disabled device: %s\n", node_name);
 			continue;
 		}
-		err = lists_bind_fdt(parent, offset_to_ofnode(offset), NULL,
-				     pre_reloc_only);
+		err = lists_bind_fdt(parent, offset_to_ofnode(offset), NULL, pre_reloc_only);
 		if (err && !ret) {
 			ret = err;
 			debug("%s: ret=%d\n", node_name, ret);
@@ -287,8 +281,7 @@ int dm_scan_fdt_dev(struct udevice *dev)
 int dm_scan_fdt(const void *blob, bool pre_reloc_only)
 {
 	if (of_live_active())
-		return dm_scan_fdt_live(gd->dm_root, gd_of_root(),
-					pre_reloc_only);
+		return dm_scan_fdt_live(gd->dm_root, gd_of_root(), pre_reloc_only);
 
 	return dm_scan_fdt_node(gd->dm_root, blob, 0, pre_reloc_only);
 }
@@ -305,8 +298,7 @@ static int dm_scan_fdt_ofnode_path(const void *blob, const char *path,
 	if (of_live_active())
 		return dm_scan_fdt_live(gd->dm_root, node.np, pre_reloc_only);
 
-	return dm_scan_fdt_node(gd->dm_root, blob, node.of_offset,
-				pre_reloc_only);
+	return dm_scan_fdt_node(gd->dm_root, blob, node.of_offset, pre_reloc_only);
 }
 
 int dm_extended_scan_fdt(const void *blob, bool pre_reloc_only)
@@ -328,15 +320,14 @@ int dm_extended_scan_fdt(const void *blob, bool pre_reloc_only)
 	for (i = 0; i < ARRAY_SIZE(nodes); i++) {
 		ret = dm_scan_fdt_ofnode_path(blob, nodes[i], pre_reloc_only);
 		if (ret) {
-			debug("dm_scan_fdt() scan for %s failed: %d\n",
-			      nodes[i], ret);
+			debug("dm_scan_fdt() scan for %s failed: %d\n", nodes[i], ret);
 			return ret;
 		}
 	}
 
 	return ret;
 }
-#endif
+#endif /* OF_CONTROL && !OF_PLATDATA */
 
 __weak int dm_scan_other(bool pre_reloc_only)
 {
@@ -385,7 +376,7 @@ static int root_acpi_get_name(const struct udevice *dev, char *out_name)
 struct acpi_ops root_acpi_ops = {
 	.get_name	= root_acpi_get_name,
 };
-#endif
+#endif /* CONFIG_ACPIGEN */
 
 /* This is the root driver - all drivers are children of this */
 U_BOOT_DRIVER(root_driver) = {
diff --git a/drivers/core/uclass.c b/drivers/core/uclass.c
index c3f1b73c..371dac1f 100644
--- a/drivers/core/uclass.c
+++ b/drivers/core/uclass.c
@@ -409,7 +409,7 @@ int uclass_find_device_by_phandle(enum uclass_id id, struct udevice *parent,
 
 	return -ENODEV;
 }
-#endif
+#endif /* OF_CONTROL */
 
 int uclass_get_device_by_driver(enum uclass_id id,
 				const struct driver *find_drv,
@@ -547,7 +547,7 @@ int uclass_get_device_by_phandle(enum uclass_id id, struct udevice *parent,
 	ret = uclass_find_device_by_phandle(id, parent, name, &dev);
 	return uclass_get_device_tail(dev, ret, devp);
 }
-#endif
+#endif /* OF_CONTROL */
 
 int uclass_first_device(enum uclass_id id, struct udevice **devp)
 {
@@ -685,7 +685,7 @@ int uclass_unbind_device(struct udevice *dev)
 	list_del(&dev->uclass_node);
 	return 0;
 }
-#endif
+#endif /* DM_DEVICE_REMOVE */
 
 int uclass_resolve_seq(struct udevice *dev)
 {
@@ -790,7 +790,7 @@ int uclass_pre_remove_device(struct udevice *dev)
 
 	return 0;
 }
-#endif
+#endif /* DM_DEVICE_REMOVE */
 
 UCLASS_DRIVER(nop) = {
 	.id		= UCLASS_NOP,
diff --git a/drivers/i2c/i2c-uclass.c b/drivers/i2c/i2c-uclass.c
index 5c4626b0..815beb1f 100644
--- a/drivers/i2c/i2c-uclass.c
+++ b/drivers/i2c/i2c-uclass.c
@@ -621,12 +621,11 @@ int i2c_chip_ofdata_to_platdata(struct udevice *dev, struct dm_i2c_chip *chip)
 {
 	int addr;
 
-	chip->offset_len = dev_read_u32_default(dev, "u-boot,i2c-offset-len",
-						1);
+	chip->offset_len = dev_read_u32_default(dev, "u-boot,i2c-offset-len", 1);
 	chip->flags = 0;
 	addr = dev_read_u32_default(dev, "reg", -1);
 	if (addr == -1) {
-		debug("%s: I2C Node '%s' has no 'reg' property %s\n", __func__,
+		debug("%s: I2C node '%s' has no 'reg' property %s\n", __func__,
 		      dev_read_name(dev), dev->name);
 		return log_ret(-EINVAL);
 	}
@@ -634,11 +633,9 @@ int i2c_chip_ofdata_to_platdata(struct udevice *dev, struct dm_i2c_chip *chip)
 
 	return 0;
 }
-#endif
 
 static int i2c_pre_probe(struct udevice *dev)
 {
-#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct dm_i2c_bus *i2c = dev_get_uclass_priv(dev);
 	unsigned int max = 0;
 	ofnode node;
@@ -646,45 +643,36 @@ static int i2c_pre_probe(struct udevice *dev)
 
 	i2c->max_transaction_bytes = 0;
 	dev_for_each_subnode(node, dev) {
-		ret = ofnode_read_u32(node,
-				      "u-boot,i2c-transaction-bytes",
-				      &max);
+		ret = ofnode_read_u32(node, "u-boot,i2c-transaction-bytes", &max);
 		if (!ret && max > i2c->max_transaction_bytes)
 			i2c->max_transaction_bytes = max;
 	}
 
 	debug("%s: I2C bus: %s max transaction bytes: %d\n", __func__,
 	      dev->name, i2c->max_transaction_bytes);
-#endif
+
 	return 0;
 }
 
 static int i2c_post_probe(struct udevice *dev)
 {
-#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct dm_i2c_bus *i2c = dev_get_uclass_priv(dev);
 
 	i2c->speed_hz = dev_read_u32_default(dev, "clock-frequency",
 					     I2C_SPEED_STANDARD_RATE);
 
 	return dm_i2c_set_bus_speed(dev, i2c->speed_hz);
-#else
-	return 0;
-#endif
 }
 
 static int i2c_child_post_bind(struct udevice *dev)
 {
-#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
 	struct dm_i2c_chip *plat = dev_get_parent_platdata(dev);
 
 	if (!dev_of_valid(dev))
 		return 0;
 	return i2c_chip_ofdata_to_platdata(dev, plat);
-#else
-	return 0;
-#endif
 }
+#endif /* OF_CONTROL && !OF_PLATDATA */
 
 struct i2c_priv {
 	int max_id;
@@ -740,11 +728,13 @@ UCLASS_DRIVER(i2c) = {
 	.post_bind	= i2c_post_bind,
 	.init		= i2c_uclass_init,
 	.priv_auto_alloc_size = sizeof(struct i2c_priv),
-	.pre_probe      = i2c_pre_probe,
-	.post_probe	= i2c_post_probe,
 	.per_device_auto_alloc_size = sizeof(struct dm_i2c_bus),
 	.per_child_platdata_auto_alloc_size = sizeof(struct dm_i2c_chip),
+#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
+	.pre_probe      = i2c_pre_probe,
+	.post_probe	= i2c_post_probe,
 	.child_post_bind = i2c_child_post_bind,
+#endif
 };
 
 UCLASS_DRIVER(i2c_generic) = {
diff --git a/drivers/power/pmic/pmic-uclass.c b/drivers/power/pmic/pmic-uclass.c
index 77701719..b8b41c80 100644
--- a/drivers/power/pmic/pmic-uclass.c
+++ b/drivers/power/pmic/pmic-uclass.c
@@ -44,8 +44,7 @@ int pmic_bind_children(struct udevice *pmic, ofnode parent,
 
 			prefix_len = strlen(info->prefix);
 			if (strncmp(info->prefix, node_name, prefix_len)) {
-				reg_name = ofnode_read_string(node,
-							      "regulator-name");
+				reg_name = ofnode_read_string(node, "regulator-name");
 				if (!reg_name)
 					continue;
 				if (strncmp(info->prefix, reg_name, prefix_len))
@@ -54,8 +53,7 @@ int pmic_bind_children(struct udevice *pmic, ofnode parent,
 
 			drv = lists_driver_lookup_name(info->driver);
 			if (!drv) {
-				debug("  - driver: '%s' not found!\n",
-				      info->driver);
+				debug("  - driver: '%s' not found!\n", info->driver);
 				continue;
 			}
 
@@ -72,8 +70,7 @@ int pmic_bind_children(struct udevice *pmic, ofnode parent,
 
 			child->driver_data = trailing_strtol(node_name);
 
-			debug("  - set 'child->driver_data': %lu\n",
-			      child->driver_data);
+			debug("  - set 'child->driver_data': %lu\n", child->driver_data);
 			break;
 		}
 
@@ -86,7 +83,7 @@ int pmic_bind_children(struct udevice *pmic, ofnode parent,
 	debug("Bound: %d children for PMIC: '%s'\n", bind_count, pmic->name);
 	return bind_count;
 }
-#endif
+#endif /* PMIC_CHILDREN */
 
 int pmic_get(const char *name, struct udevice **devp)
 {
diff --git a/drivers/power/pmic/rk8xx.c b/drivers/power/pmic/rk8xx.c
index 148ee29c..ca866644 100644
--- a/drivers/power/pmic/rk8xx.c
+++ b/drivers/power/pmic/rk8xx.c
@@ -12,26 +12,28 @@
 #include <power/pmic.h>
 
 static struct reg_data rk817_init_reg[] = {
-/* enable the under-voltage protection,
- * the under-voltage protection will shutdown the LDO3 and reset the PMIC
- */
-	{ RK817_BUCK4_CMIN, 0x60, 0x60},
+	/*
+	 * Enable the under-voltage protection, which
+	 * will shutdown the LDO3 and reset the PMIC.
+	 */
+	{ RK817_BUCK4_CMIN, 0x60, 0x60 },
 };
 
+#if CONFIG_IS_ENABLED(PMIC_CHILDREN)
 static const struct pmic_child_info pmic_children_info[] = {
-	{ .prefix = "DCDC_REG", .driver = "rk8xx_buck"},
-	{ .prefix = "LDO_REG", .driver = "rk8xx_ldo"},
-	{ .prefix = "SWITCH_REG", .driver = "rk8xx_switch"},
+	{ .prefix = "DCDC_REG", .driver = "rk8xx_buck" },
+	{ .prefix = "LDO_REG", .driver = "rk8xx_ldo" },
+	{ .prefix = "SWITCH_REG", .driver = "rk8xx_switch" },
 	{ },
 };
+#endif /* PMIC_CHILDREN */
 
 static int rk8xx_reg_count(struct udevice *dev)
 {
 	return RK808_NUM_OF_REGS;
 }
 
-static int rk8xx_write(struct udevice *dev, uint reg, const uint8_t *buff,
-			  int len)
+static int rk8xx_write(struct udevice *dev, uint reg, const uint8_t *buff, int len)
 {
 	int ret;
 
@@ -79,7 +81,7 @@ static int rk8xx_bind(struct udevice *dev)
 	/* Always return success for this device */
 	return 0;
 }
-#endif
+#endif /* PMIC_CHILDREN */
 
 static int rk8xx_probe(struct udevice *dev)
 {
-- 
2.33.1

